{
  "name": "verror",
  "version": "1.3.4",
  "description": "richer JavaScript errors",
  "main": "./lib/verror.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/davepacheco/node-verror.git"
  },
  "dependencies": {
    "extsprintf": "1.0.0"
  },
  "engines": [
    "node >=0.6.0"
  ],
  "scripts": {
    "test": "make test"
  },
  "readme": "# verror: richer JavaScript errors\r\n\r\nThis module provides two classes: VError, for accretive errors, and WError, for\r\nwrapping errors.  Both support printf-style error messages using extsprintf.\r\n\r\n## Printf-style errors\r\n\r\nAt the most basic level, VError is just like JavaScript's Error class, but with\r\nprintf-style arguments:\r\n\r\n    var verror = require('verror');\r\n\r\n    var opname = 'read';\r\n    var err = new verror.VError('\"%s\" operation failed', opname);\r\n    console.log(err.message);\r\n    console.log(err.stack);\r\n\r\nThis prints:\r\n\r\n    \"read\" operation failed\r\n    \"read\" operation failed\r\n        at Object.<anonymous> (/Users/dap/node-verror/examples/varargs.js:4:11)\r\n        at Module._compile (module.js:449:26)\r\n        at Object.Module._extensions..js (module.js:467:10)\r\n        at Module.load (module.js:356:32)\r\n        at Function.Module._load (module.js:312:12)\r\n        at Module.runMain (module.js:492:10)\r\n        at process.startup.processNextTick.process._tickCallback (node.js:244:9)\r\n\r\n\r\n## VError for accretive error messages\r\n\r\nMore interestingly, you can use VError to build up an error describing what\r\nhappened at various levels in the stack.  For example, suppose you have a\r\nrequest handler that stats a file and fails if it doesn't exist:\r\n\r\n    var fs = require('fs');\r\n    var verror = require('verror');\r\n\r\n    function checkFile(filename, callback) {\r\n        fs.stat(filename, function (err) {\r\n            if (err)\r\n\t\t/* Annotate the \"stat\" error with what we were doing. */\r\n\t    \treturn (callback(new verror.VError(err,\r\n\t\t    'failed to check \"%s\"', filename)));\r\n\r\n\t    /* ... */\r\n        });\r\n    }\r\n\r\n    function handleRequest(filename, callback) {\r\n    \tcheckFile('/nonexistent', function (err) {\r\n    \t    if (err) {\r\n    \t    \t/* Annotate the \"checkFile\" error with what we were doing. */\r\n    \t    \treturn (callback(new verror.VError(err, 'request failed')));\r\n    \t    }\r\n\r\n    \t    /* ... */\r\n    \t});\r\n    }\r\n\r\n    handleRequest('/nonexistent', function (err) {\r\n\tif (err)\r\n\t\tconsole.log(err.message);\r\n\t/* ... */\r\n    });\r\n\r\nSince the file \"/nonexistent\" doesn't exist, this prints out:\r\n\r\n    request failed: failed to check \"/nonexistent\": ENOENT, stat '/nonexistent'\r\n\r\nThe idea here is that the lowest level (Node's \"fs.stat\" function) generates an\r\narbitrary error, and each higher level (request handler and stat callback)\r\ncreates a new VError that annotates the previous error with what it was doing,\r\nso that the result is a clear message explaining what failed at each level.\r\n\r\nThis plays nicely with extsprintf's \"%r\" specifier, which prints out a\r\nJava-style stacktrace with the whole chain of exceptions:\r\n\r\n    EXCEPTION: VError: request failed: failed to check \"/nonexistent\": ENOENT, stat '/nonexistent'\r\n        at /Users/dap/work/node-verror/examples/levels.js:21:21\r\n        at /Users/dap/work/node-verror/examples/levels.js:9:12\r\n        at Object.oncomplete (fs.js:297:15)\r\n    Caused by: EXCEPTION: VError: failed to check \"/nonexistent\": ENOENT, stat '/nonexistent'\r\n        at /Users/dap/work/node-verror/examples/levels.js:9:21\r\n        at Object.oncomplete (fs.js:297:15)\r\n    Caused by: EXCEPTION: Error: Error: ENOENT, stat '/nonexistent'\r\n\r\n\r\n## WError for wrapped errors\r\n\r\nSometimes you don't want an Error's \"message\" field to include the details of\r\nall of the low-level errors, but you still want to be able to get at them\r\nprogrammatically.  For example, in an HTTP server, you probably don't want to\r\nspew all of the low-level errors back to the client, but you do want to include\r\nthem in the audit log entry for the request.  In that case, you can use a\r\nWError, which is created exactly like VError (and also supports both\r\nprintf-style arguments and an optional cause), but the resulting \"message\" only\r\ncontains the top-level error.  It's also more verbose, including the class\r\nassociated with each error in the cause chain.  Using the same example above,\r\nbut replacing the VError in handleRequest with WError, we get this output:\r\n\r\n    request failed\r\n\r\nThat's what we wanted -- just a high-level summary for the client.  But we can\r\nget the object's toString() for the full details:\r\n\r\n    WError: request failed; caused by WError: failed to check \"/nonexistent\";\r\n    caused by Error: ENOENT, stat '/nonexistent'\r\n\r\n# Contributing\r\n\r\nContributions welcome.  Code should be \"make check\" clean.  To run \"make check\",\r\nyou'll need these tools:\r\n\r\n* https://github.com/davepacheco/jsstyle\r\n* https://github.com/davepacheco/javascriptlint\r\n\r\nIf you're changing something non-trivial or user-facing, you may want to submit\r\nan issue first.\r\n",
  "readmeFilename": "README.md",
  "_id": "verror@1.3.4",
  "dist": {
    "shasum": "666aef1119644749f72dba6e6dcb39e470a59883"
  },
  "_from": "verror@git://github.com/davepacheco/node-verror.git#35e55e8"
}
